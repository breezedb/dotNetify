{"componentChunkName":"component---src-templates-blog-post-js","path":"/realtime-postgres/","result":{"data":{"site":{"siteMetadata":{"title":"dotNetify"}},"markdownRemark":{"id":"a5f69696-b160-5621-b1e9-ed146f02db0e","excerpt":"I was reading up on PostgreSQL for my day job when I noticed this nifty feature called logical replication. Logical replication, as the PostgreSQL documentation…","html":"<p>I was reading up on PostgreSQL for my day job when I noticed this nifty feature called logical replication. Logical replication, as the PostgreSQL documentation states, is “a method of replicating data objects and their changes, based upon their replication identity (usually a primary key)“. In other words, it’s a way of ensuring copies of the database are always in sync by having the database publish logical data changes in real-time to subscriber nodes. Typically the subscribers would be other PostgreSQL databases that are serving as copies of the master, but they could actually be anything, including, say, a .NET service that can push those changes to web apps in real-time.</p>\n<p>PostgreSQL has another feature called NOTIFY to generate notifications but we typically need to set it up with database triggers that we have to write for each table we’re interested in, and the string payload size has a limit of 8000 bytes. Logical replication has no such limit and can listen to all tables with a single database connection, making it pretty scalable.</p>\n<p>So, combining it with the real-time web framework <em>dotNetify</em>, I wrote a small library that you can use to develop a web application with ASP.NET 5 that can react to all the inserts, updates and deletes that any user of the app commits to your PostgreSQL database. With this, your app won’t involve expensive polling, a complicated pub/sub pipeline, or even take much code at all. The rest of the blog will talk about how you can build such app.</p>\n<h2>PostgreSQL Setup</h2>\n<p>To enable logical replication in your PostgreSQL database, find the <em>postgresql.conf</em> configuration file, change a parameter called <em>wal</em>level_ to <em>logical</em>, and both <em>max</em>wal<em>senders</em> and _ <em>max</em>replication<em>slots</em> to at least 1. They will take effect after the service is restarted. You can also change them through SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">ALTER</span> SYSTEM <span class=\"token keyword\">SET</span> wal_level<span class=\"token operator\">=</span><span class=\"token string\">'logical'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">ALTER</span> SYSTEM <span class=\"token keyword\">SET</span> max_wal_senders<span class=\"token operator\">=</span><span class=\"token string\">'10'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">ALTER</span> SYSTEM <span class=\"token keyword\">SET</span> max_replication_slots<span class=\"token operator\">=</span><span class=\"token string\">'10'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The next step is to create a publication:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> PUBLICATION my_pub <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">TABLES</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We set it to publish data changes for all tables, but you can restrict it to just a specific table.</p>\n<p>When the PostgreSQL is publishing replication records (also known as write-ahead logs or WAL), it uses something called replication slots to ensure that the records do not get deleted until they’re received by the subscribers. This is a great feature, as it affords a subscriber to go temporarily offline, and to simply pick up where it left off when it reconnects. But there’s a caveat: the WAL records can pile up in a prolonged disconnection event, to the point that it can run out of space and crash the database, and therefore, the slots will need to be monitored.</p>\n<p>The followins statemnt will create a replication slot:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> pg_create_logical_replication_slot<span class=\"token punctuation\">(</span><span class=\"token string\">'my_slot'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pgoutput'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <em>pgoutput</em> is PostgreSQL’s standard logical decoding plugin for transforming the changes from WAL to the logical replication protocol. If in the future you want to remove the slot, simply run this command: <code class=\"language-text\">SELECT * FROM pg_drop_replication_slot(&#39;my_slot&#39;);</code>.</p>\n<p>For our demo, let’s create a simple table, followed by a user for the ASP.NET service that will be connecting to the database:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span> businesses <span class=\"token punctuation\">(</span>\n\tbusiness_id <span class=\"token keyword\">serial</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>\n\tbusiness_name <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">50</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n\trating <span class=\"token keyword\">integer</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> my_user <span class=\"token keyword\">WITH</span> PASSWORD <span class=\"token string\">'my_pwd'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">ALTER</span> ROLE my_user <span class=\"token keyword\">WITH</span> <span class=\"token keyword\">REPLICATION</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">PRIVILEGES</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">ALL</span> <span class=\"token keyword\">TABLES</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">SCHEMA</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">TO</span> my_user<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">USAGE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">ALL</span> SEQUENCES <span class=\"token operator\">IN</span> <span class=\"token keyword\">SCHEMA</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">TO</span> my_user<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Notice that we give the REPLICATION role to the user. Having this role is required for subscribing to replication slots.</p>\n<h2>DotNetify Web Service</h2>\n<p>Now that we’ve configured the Postgres, the next step is to introduce an ASP.NET web service to subscribe to the replication slot we just created and push the changes to its web page using the <em>DotNetify.Postgres</em> library. You can download the source code from <a href=\"https://github.com/dsuryd/dotNetify/tree/master/Demo/React/RealtimeDb.Postgres\">this github repo</a>. This simple demo project uses React/Typescript front-end with Webpack. After installing the npm packages, you can run the project from either Visual Studio or dotnet CLI.</p>\n<p>In the code, the PostgreSQL table we’ve created is mapped to a C# type:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace RealtimeDb.ViewModels\n{\n  [Table(&quot;businesses&quot;)]\n  public class Business\n  {\n    [Column(&quot;business_id&quot;)]\n    [Key]\n    public long Id { get; set; }\n\n    [Column(&quot;business_name&quot;)]\n    public string Name { get; set; }\n\n    [Column(&quot;rating&quot;)]\n    public int Rating { get; set; }\n  }\n}</code></pre></div>\n<p>The <em>DotNetify.Postgres</em> library provides a ReactiveX interface to listen to PostgreSQL data change events. The interface is injected into a <em>dotNetify</em> view model so it can subscribe to the events when the associated React webpage is active and push any updates in real-time:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">using System;\nusing System.Collections.Generic;\nusing System.Reactive.Linq;\nusing DotNetify;\nusing DotNetify.Postgres;\n\nnamespace RealtimeDb.ViewModels\n{\n   public class ListenOnlyVM : BaseVM\n   {\n      private IDisposable _subs;\n\n      // Real-time list; documentation: https://dotnetify.net/core/api/crud.\n      [ItemKey(nameof(Business.Id))]\n      public List&lt;Business&gt; Businesses { get; set; }\n\n      public ListenOnlyVM(IDbChangeObserver dbChangeObserver)\n      {\n         Businesses = new List&lt;Business&gt;();\n\n         _subs = dbChangeObserver.Observe&lt;Business&gt;().Subscribe(e =&gt;\n         {\n            if (e is DbInsertEvent&lt;Business&gt;)\n            {\n               this.AddList(nameof(Businesses), (e as DbInsertEvent&lt;Business&gt;).Row);\n            }\n            else if (e is DbUpdateEvent&lt;Business&gt;)\n            {\n               this.UpdateList(nameof(Businesses), (e as DbUpdateEvent&lt;Business&gt;).NewRow);\n            }\n            else if (e is DbDeleteEvent&lt;Business&gt;)\n            {\n               var key = (e as DbDeleteEvent&lt;Business&gt;).Row.Id;\n               this.RemoveList(nameof(Businesses), key);\n            }\n\n            PushUpdates();\n         });\n      }\n\n      public override void Dispose() =&gt; _subs.Dispose();\n   }\n}</code></pre></div>\n<p>The connection string to our PostgreSQL database along with the publication and replication slot names are configured in the service startup class:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public class Startup\n{\n  public IConfiguration Configuration { get; }\n\n  public Startup(IConfiguration configuration)\n  {\n      Configuration = configuration;\n  }\n\n  public void ConfigureServices(IServiceCollection services)\n  {\n      services.AddSignalR();\n      services.AddDotNetify();\n      services.AddDotNetifyPostgres(new PostgresConfiguration\n      {\n        ConnectionString = Configuration.GetConnectionString(&quot;Postgres&quot;),\n        PublicationName = &quot;my_pub&quot;,\n        ReplicationSlotName = &quot;my_slot&quot;\n      });\n  }\n  ...\n}</code></pre></div>\n<p>And that’s all there is to it for the server-side code! Here’s what the demo app looks like as it reacted to data changes that were made from pgAdmin.</p>\n<p><img src=\"/dotNetify/493674e3d078e6e7145815c83e4414b1/listen-only.gif\" alt=\"Listener Demo\"></p>\n<h2>Integrating EF Core</h2>\n<p>So far we have a web page that’s only reacting to data changes on the database. Let’s take it a step further and make it capable of supporting CRUD operations as well. For this, we’re going to use the <a href=\"https://www.npgsql.org/\">Npgsql</a> library to access PostgreSQL, and can be used with the Entity Framework Core.</p>\n<p>Add a DBContext for our demo table:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">using Microsoft.EntityFrameworkCore;\n\nnamespace RealtimeDb\n{\n   public class BusinessDbContext : DbContext\n   {\n      public DbSet&lt;Business&gt; Businesses { get; set; }\n\n      public BusinessDbContext(DbContextOptions&lt;BusinessDbContext&gt; options) : base(options)\n      {\n      }\n   }\n}</code></pre></div>\n<p>Configure the EF Core in the startup class:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public class Startup\n{\n  public void ConfigureServices(IServiceCollection services)\n  {\n    ...\n    services.AddDbContextFactory&lt;BusinessDbContext&gt;(options =&gt;\n      options.UseNpgsql(Configuration.GetConnectionString(&quot;Postgres&quot;)));\n  }\n}</code></pre></div>\n<p>Lastly, write the view model with the CRUD methods:</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public class BusinessesVM : BaseVM\n{\n  private readonly IDbContextFactory&lt;BusinessDbContext&gt; _dbContextFactory;\n\n  [ItemKey(nameof(Business.Id))]\n  public List&lt;Business&gt; Businesses { get; set; }\n\n  public BusinessesVM(IDbContextFactory&lt;BusinessDbContext&gt; dbContextFactory, IDbChangeObserver dbChangeObserver)\n  {\n      _dbContextFactory = dbContextFactory;\n\n      using var dbContext = _dbContextFactory.CreateDbContext();\n      Businesses = dbContext.Businesses.OrderBy(x =&gt; x.Id).ToList();\n\n      this.ObserveList&lt;Business&gt;(nameof(Businesses), dbChangeObserver);\n  }\n\n  public void Add(Business businessInfo)\n  {\n      using var dbContext = _dbContextFactory.CreateDbContext();\n      dbContext.Businesses.Add(businessInfo);\n      dbContext.SaveChanges();\n  }\n\n  public void Update(Business businessInfo)\n  {\n      using var dbContext = _dbContextFactory.CreateDbContext();\n      var business = dbContext.Businesses.Find(businessInfo.Id);\n      if (business != null)\n      {\n        business.Name = businessInfo.Name;\n        business.Rating = businessInfo.Rating;\n        dbContext.SaveChanges();\n      }\n  }\n\n  public void Remove(Business businessInfo)\n  {\n      using var dbContext = _dbContextFactory.CreateDbContext();\n      var business = dbContext.Businesses.Find(businessInfo.Id);\n      if (business != null)\n      {\n        dbContext.Businesses.Remove(business);\n        dbContext.SaveChanges();\n      }\n  }\n}</code></pre></div>\n<p>Notice that the code that does the subscription and data change event handling are gone. In its place is now a call to <em>ObserveList</em> extension method, which serves as a shorthand.</p>\n<p>And here’s the demo of two instances of the app keeping in sync with each other while we apply some CRUD operations:</p>\n<p><img src=\"/dotNetify/76b2b86d54ccd8e7f202a8cea66e5236/businesses-crud.gif\" alt=\"CRUD Demo\"></p>\n<p>I hope this is useful to you! I’d be interested to hear what you think. Reply to the tweet below and let me know. And feel free to retweet!</p>","frontmatter":{"title":"How To Do Real-time Web Updates From Your PostgreSQL Database","date":"March 31, 2021","description":"Combine PostgreSQL logical replication feature with dotNetify to broadcast data changes to your website in real-time."}},"previous":null,"next":{"fields":{"slug":"/scale-out/"},"frontmatter":{"title":"Recreating \"Azure SignalR\" Scale-Out"}}},"pageContext":{"id":"a5f69696-b160-5621-b1e9-ed146f02db0e","previousPostId":null,"nextPostId":"c0d6e475-216a-549f-b08a-92f269890062"}},"staticQueryHashes":["2841359383","3257411868"]}