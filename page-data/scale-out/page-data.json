{"componentChunkName":"component---src-templates-blog-post-js","path":"/scale-out/","result":{"data":{"site":{"siteMetadata":{"title":"DotNetify"}},"markdownRemark":{"id":"8fa63cce-55f8-5eac-982c-a0a3305e79c3","excerpt":"DotNetify: Adding “Azure SignalR”-like Scale-Out Option A few weeks ago dotNetify passed the 100k downloads on NuGet. I’m so thrilled that so many people have…","html":"<h1>DotNetify: Adding “Azure SignalR”-like Scale-Out Option</h1>\n<p>A few weeks ago dotNetify passed the 100k downloads on NuGet. I’m so thrilled that so many people have found this project compelling enough to try out, and even use it in production! For those who are unfamiliar with dotNetify, it’s an Apache2-licensed FOSS that does this in a nutshell:</p>\n<blockquote>\n<p>dotNetify provides a layer of MVVM-styled abstraction over SignalR to facilitate real-time communication between the web front-end of your application and its ASP.NET Core back-end.</p>\n</blockquote>\n<p>It offers built-in integration with some client-side frameworks, such as React, Vue, and Blazor, resulting in code that’s declarative, concise, and easy to read. For example, here’s what it would look like to implement a rudimentary stock ticker UI using Vue:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/cd536/stock-ticker-code.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB2ElEQVQoz22Ry27TQBSG8wqQRKSosefmGTu+pUkR4gWoRJKC4E27aFkECbFAwKLtoouuEKCuGuXmOPbM2B5zLBUhJI6O/tX85/vPmZYfekejsYDiHARjjGxECen1eicnL2+vv95efZ5/vDx7/+3s4svFh6v5p5vz+fX5/BK6ZVt94sWD0Ys48MPx8/DoOIpib/jsENPXb99lZf3rLkuSVf2/aiFkUe578bEXxm44dIMh9wIm3INDa3b6ZqOSzVqmqSwq03RZVZVp2jTawgg7IkDMtW1EbIsgy+r3bctqP370ajIzdZ3uytXabHfFNtcwJM/zoigfyASTOByP4rHHBcOYYYRgDEKdTnsymcGLfVpudmqviyStklTvdkmaKq2rugYywWLgR1HoDnzKXYdTwYjrsCcHT6fTUzDnmVqutpvtNlMKHLooof6QCRGuCKLI8wRqqBDZeiBPm9hAWK+XP77/XNyv8zwzxvw9GKHUBx8XiDqYMMIFjIMZ7XZjbqzGyDxbLJZpmmmt/jHDxwo/8KIhdwhzHMJdTB3uDrrdLuxcNbH1fl8o3ezZiNZSymyfweValDFKKMKQAAMTU2YjEKfb7QC5NLlSpVJGSiVlKaXWRaGUznMJ+hs9v0ztfT1RaAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Stock Ticker - Vue\"\n        title=\"Stock Ticker - Vue\"\n        src=\"/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/f058b/stock-ticker-code.png\"\n        srcset=\"/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/c26ae/stock-ticker-code.png 158w,\n/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/6bdcf/stock-ticker-code.png 315w,\n/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/f058b/stock-ticker-code.png 630w,\n/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/40601/stock-ticker-code.png 945w,\n/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/cd536/stock-ticker-code.png 1114w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Doesn’t it look clean and simple? With dotNetify, you only write views and its view models, and you automatically get easy access to the bidirectional, real-time functionality provided by SignalR without having to write the low-level code yourself.</p>\n<h2>SignalR Scale-Out Options</h2>\n<p>Running a dotNetify app on a single server is pretty straightforward, but on a few occasions there were questions about its scalability in a multi-server architecture. Scaling SignalR horizontally is tricky compared to REST APIs. There are at least two major issues to address:</p>\n<ol>\n<li>Given the connection is stateful, when a client sends a request to an app server, subsequent requests need to stay on that server.</li>\n<li>A server is only aware of its own client connections. And so if the app needs to broadcast, it needs a way to get the payload on all the app servers so they can broadcast it to their respective clients.</li>\n</ol>\n<p>The first issue can be solved by either configuring the load balancer to always direct the requests from a particular client to the same server (so-called “sticky sessions”), or making SignalR skips its transport negotiation and straight to persistent WebSocket connection. But both give rise to a harder problem: sticky connections persist on one server; when that server is at capacity, how do we redistribute the load to a new server?</p>\n<p>The second issue is commonly addressed by having an intermediary server with a pub/sub channel to which every app server subscribes. Incoming client messages to one server are published to the channel so the other servers may get them as well. Microsoft’s SignalR documentation refers to this as a “backplane”, with Redis being the recommended technology.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 614px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.59493670886076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACKklEQVQoz2VTTW8SQRjeH+RNDx5MvHoxeDImJh6IcquJmnrQg02L/gDOcPFmTcpJCAfjAZpiJBUL1dBSWpbvsmzZL2BmZ/ZxZteFpT7JZD7yzjPP+7zvKNVqFYVCAeVyGRKe560NhLOAadk4b3dACEEIz6Xgi5k/5FrJ5/NIJBKIxWJrhMu1mBnj/v5b8QCPn75A60L194RSsLkgogRcDkGqZLNZlEol5HI56JYLzldkqwc4CAM+7eVw4/Y9/Kr9BhNqpoYBOnMAzuAxBk7mUBCBNaPQDLIkCskNx8Wk10Vx/wAv37zHhdpd3pEkQR7BWlFVFf1+H7p+5R/qJvUJQjAR22t3QU0NV1MDlmn6HoZ2cLKAZ1uglyORsiCsVCp4vrGBzc3XwGwKd9JDRxhfq9VRPz7G6UkD9qWK6wgt4S7B0ZOHKN+5iYWuQUmn00ilUtjaehcY7S4w1vs4a56h0WgI5RPo9hhUXJSSQnUIE/UYWvkvONn7DIjCKMPhEFRUK8R4OoDL3DU1RASa8wn2v//Aq7cf0OkNAnUybZFyezDAubDNT3k0GsEQ1SKEiiqPYc+tf8E80o8B8cfdXdy6+wBH9T9wxSPSUzqzfbUyyCc8/HmI7e1tJJM7mFPnv5bxCyNaQqLwtYj7j56hcdoKzjkPmjrah5lMRpAlEY/HA2U8ogyrJpfnshtUtQPHcVbFEfYsf4pYK81mE5qmrRNd+y2rvmTLrxiNieIvSo99waJyhU8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Redis Backplane\"\n        title=\"Redis Backplane\"\n        src=\"/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png\"\n        srcset=\"/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/c26ae/backplane.png 158w,\n/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/6bdcf/backplane.png 315w,\n/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png 614w\"\n        sizes=\"(max-width: 614px) 100vw, 614px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>In 2018, Microsoft started to offer its own cloud solution versus Redis — the Azure SignalR Service. What’s interesting is that it doesn’t use a pub/sub broker, but what looks to be a cluster of reverse proxies. Instead of duplicating the app servers, it puts this cluster of proxy servers in front of the app server and maintains a fixed number of persistent connections between them. Any client that attempts to connect to the app server will be redirected to establish the connection with a proxy, which then forward messages from the client to the app server and vice versa.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 484px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.31645569620254%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGklEQVQ4y5VUO48SURSe/0OrFnRIbWFNLaEyWSu0tuIHuKEihFCQQNzCwgJJpAAKYHV5uLjGjbLjME/GOzzmyee9l2VgF9aEk5zcO/ee+eac831nBEIIWq0Wms0mer0eRFGE7/tgtlqtuB9jQrvdRqPRgGEYSCQSSKVSCIIt4O56yDYf3bigaRqy2SxyuRySySSi0Shsd7UHuOv371hFzDkgO5RlGZ1OB6ZpQtc1yIYN03L3wO634VDmwubQdV14nhde3KgLOK5/JzgIgu3+9j2W2afPDXz4WMNiuYTAgljZzB3HCUF9Gn+j2fD8ABONQNLmEBWCsTSlwNvMXBqffPkGzxMpqJoOodvtolarYTgcIp1O493pKZwZwWoxBaFEXV5r0E0L518uOHHW3MXP3woIMW9bRMl8cYKnzxKQFQ0Ck0qpVOJMx2IxPHr8BPCWsHUJvqXg6tcEE9XExddzSJKEH2MDMs3Y91zeptl8jpPXbynoK5qhsSalWq2iXC5zPZ6dvQ/LkaYiphYtc/IXynRBVwLVmN3pq2VZGH67xOj7FWzbXgMyYwLfNYOolGk9fHZcLyRll2nW83XvXX7PWVYUhfuSsuR5Phb2jEpHPDgtD+1D2YxGI05Kv99HJpNBsVjEH3UMP/D+K+qHRC8MBgNUKhUu7Hg8jkgkspfBMfMcklIoFFCv15HP5/fm9Kifw2ajqurBph8L+A+Xa2SJzQ6IvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Azure SignalR\"\n        title=\"Azure SignalR\"\n        src=\"/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png\"\n        srcset=\"/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/c26ae/azure-signalr.png 158w,\n/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/6bdcf/azure-signalr.png 315w,\n/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png 484w\"\n        sizes=\"(max-width: 484px) 100vw, 484px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The messages are multiplexed through that constant number of connections, which means that the app server won’t be sensitive to how many active client connections there are, only the message throughput.\nThe proxy scale-out method seems to be the better option because:\nThe app server won’t need to scale just to handle a large number of concurrent connections, especially when they’re mostly idle.</p>\n<ol>\n<li>The app server won’t waste its resources on maintaining connections.</li>\n<li>The app server is aware of all the (logical) connections and can use connection ids to track clients.</li>\n<li>You won’t have to deal with the hassle of managing (or paying for) Redis.</li>\n</ol>\n<p>The obvious downside is that if you can’t / won’t run on Azure, then you don’t get that option! Even when the cost factor is omitted, many still face restriction on which cloud provider they can use, if at all.</p>\n<p>In the following section I describe my effort to update dotNetify so its apps can use the proxy scale-out option either on-prem or on non-Azure cloud providers.</p>\n<h2>Forwarding Middleware</h2>\n<p>The Azure SignalR service is not open source, so I could only guess how the proxying is actually done, but it can be surmised that the ability to forward messages from one SignalR hub server to another is the critical piece. The thought of using the dotNetify middleware mechanism immediately jumped out to me.<br>\nDotNetify middlewares are similar to ASP.NET middlewares in concept, but instead of HTTP requests, they intercept SignalR messages. They are intended to process payload metadata, such as JWT access tokens and custom initialization arguments, and can be chained like a pipeline.</p>\n<p>The idea I ran with was to introduce a middleware that makes a fixed number of SignalR connections to an app server and passes all client messages through these connections. It also needs to be bi-directional — to pass messages from the app server to the intended clients. In essence, its purpose is to facilitate logical connections between the app server and the clients. Implementing scale-out then becomes a matter of enabling this middleware on some plain, inexpensive proxy servers:</p>\n<p>A proxy server is simply a bare-bone ASP.NET Core web app with the following code in Startup.cs:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 599px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.39240506329114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5UlEQVQoz31Tu47TQBT1T/EB/EF6pKWiWSqkFKRDSofSAEsVEokS0VCRIg9twaJEKGSTFImMnDjRxgTj9yP2esY+eMYkIcPCkcZ3Hude33vmjjSdTjEajdDpdKAoChiyLDvYu+Z7iOcMUrvd5gFLpRLK5TLfJIScOBfzYh3HMcIw5FYMzIa0WCzQaDTQan1Et3cJn/OyExJb0zSD7RN8vvqE4XCI2WyG3W73V9YSBFhuDDdIxG38NH3Y2hqmZWG1WkHXdR7QcRykaXoMyA4nkwkneb5fOLsEYUyRMWKWwg0JtuoSoDEvnEmyD8LmG22Lp8+eo3N5Banb7UKWZZydPcTri4ucEeDW1iF/UzAeX2N0PcZakUFD+7dex2wopdze5AHv3S/hzdt3kAaDAer1OqrVKrcMnqvnJW6xudlA077DD5w86y3uAqUES3WNB4+e4P2HVqEh02EPklIYno5McIxuQxjuD0RRhCAI+C0zDT3Pg+u6WC5VWJYNyTAMsJs2TRMJSaA7GghNhHYoyoySEMOvX9Dv9zGfz/PstQOPacp4Uq/X4xqenz/Gy1cvCkIqts2xcVlG7AGoqnrQ8M/W4Ro2m01UKhXUarWi7FwXsWFFx9OmP3Il9mEZsu4Xg/zvCf7rR78ALBWFjFlNb84AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Forwarding Proxy\"\n        title=\"Forwarding Proxy\"\n        src=\"/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png\"\n        srcset=\"/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/c26ae/forwarding-proxy.png 158w,\n/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/6bdcf/forwarding-proxy.png 315w,\n/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png 599w\"\n        sizes=\"(max-width: 599px) 100vw, 599px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>An important consideration for me was to make sure that the view models or other middlewares won’t be aware of the proxies. A multicast view model that uses connection ids to track clients shouldn’t be implemented any different when it’s operating behind proxies than when it’s not. This was solved by having the receiver end on the app server create a logical connection context that exposes the original connection id.</p>\n<h2>Forwarding Options</h2>\n<p>The forwarding middleware provides the following options:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">DotNetify</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">DotNetify<span class=\"token punctuation\">.</span>Forwarding</span><span class=\"token punctuation\">;</span>\n<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">ProxyServer</span>\n<span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Startup</span>\n   <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">ConfigureServices</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IServiceCollection</span> services<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">{</span>\n         services<span class=\"token punctuation\">.</span><span class=\"token function\">AddSignalR</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         services<span class=\"token punctuation\">.</span><span class=\"token function\">AddDotNetify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Configure</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IApplicationBuilder</span> app<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">{</span>\n         app<span class=\"token punctuation\">.</span><span class=\"token function\">UseWebSockets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         app<span class=\"token punctuation\">.</span><span class=\"token function\">UseDotNetify</span><span class=\"token punctuation\">(</span>config <span class=\"token operator\">=></span>\n         <span class=\"token punctuation\">{</span>\n            config<span class=\"token punctuation\">.</span><span class=\"token function\">UseForwarding</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;app_server_url>\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         app<span class=\"token punctuation\">.</span><span class=\"token function\">UseRouting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         app<span class=\"token punctuation\">.</span><span class=\"token function\">UseEndpoints</span><span class=\"token punctuation\">(</span>ep <span class=\"token operator\">=></span> ep<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">MapHub</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>DotNetifyHub<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/dotnetify\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>ConnectionPoolSize:</strong> the number of SignalR connections the proxy server will establish with the app server. Messages to be delivered will take turns using a connection from the pool in a round-robin fashion. Naturally, the pool size should be increased if the anticipated throughput is high.</p>\n<p><strong>Filter:</strong> optional predicate for whether or not to forward a message. Chaining multiple forwarding middlewares with filters allow for all kinds of interesting configuration, such as having specialized app servers handling different user groups or certain types of view models.</p>\n<p><strong>UseMessagePack:</strong> use MessagePack serialization format to keep the payload small.</p>\n<p><strong>HaltPipeline:</strong> stop processing beyond the middleware. This flag allows the middleware to be used not just for scale-out, but for observability, i.e. sending messages to a real-time monitoring server.</p>\n<h2>Devising Load Tests</h2>\n<p>Needless to say, substantial code refactoring had to be done to dotNetify for this, and I needed to build confidence that the whole thing would actually work! First, I would need a load testing tool to emulate a high number of concurrent client connections. There’s a Microsoft tool called Crankier, but it only tries to hold open connections and not measuring anything related to the message payload.</p>\n<p>In the end, I built my own tool that can be customized for any kind of workload, and wrote some test profiles according to what I thought were the most common ones:</p>\n<ul>\n<li>Broadcast: The server pushes updates to all clients at regular intervals. A single multicast view model instance is used.</li>\n<li>Echo: Continuous back and forth communication between the client and the server. The server sends a message to the client and waits for the response before sending the next one.</li>\n<li>Chat Room: This profile models chat rooms where clients are sending and receiving messages with each other and within groups. The clients within a group are configured into 3 types:</li>\n</ul>\n<div style=\"margin-left: 30px\">\n<ul>\n<li>Chatty posters (10%): send message every 11 seconds.</li>\n<li>Casual posters (20%): send message every 59 seconds.</li>\n<li>Lurkers (70%): only receive messages.</li>\n</ul>\n</div>\n<p>The message payload contains a sequence number and a timestamp to allow the test to detect for undelivered messages and measure the average round-trip latency. You can view the source code here.</p>\n<p>Next, I created an app server with the test view models and deployed it along with 2 proxy servers to a free-tier Heroku container environment. According to the specs, each server node only has 500MB memory and 1x CPU share, so I would have to balance the number of the connections with the throughput so as not to overwhelm the resources.</p>\n<p>I ran my tool from my own machine to emulate client connections. I set the connections to 1000 (following the limit on an Azure SignalR standard unit) with a new connection every 100 ms, running broadcast test with 3 seconds interval for 5 minutes. The results:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// dotnetify-proxy1.herokuapp.com</span>\nClients<span class=\"token operator\">=</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> Received<span class=\"token operator\">=</span><span class=\"token number\">134262</span><span class=\"token punctuation\">,</span> Missed<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token operator\">%</span><span class=\"token punctuation\">,</span> Min interval<span class=\"token operator\">=</span><span class=\"token number\">3003.35</span><span class=\"token punctuation\">,</span> Max interval<span class=\"token operator\">=</span><span class=\"token number\">3088.73</span><span class=\"token punctuation\">,</span> Avg interval<span class=\"token operator\">:</span> <span class=\"token number\">3034.29</span>\n\n<span class=\"token comment\">// dotnetify-proxy2.herokuapp.com</span>\nClients<span class=\"token operator\">=</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> Received<span class=\"token operator\">=</span><span class=\"token number\">134263</span><span class=\"token punctuation\">,</span> Missed<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token operator\">%</span><span class=\"token punctuation\">,</span> Min interval<span class=\"token operator\">=</span><span class=\"token number\">3004.32</span><span class=\"token punctuation\">,</span> Max interval<span class=\"token operator\">=</span><span class=\"token number\">3122.66</span><span class=\"token punctuation\">,</span> Avg interval<span class=\"token operator\">:</span> <span class=\"token number\">3034.98</span></code></pre></div>\n<p>With each connection passing 20 messages/minute, 2000 concurrent connections running for just 1 day would generate close to 58 million messages and would’ve cost me about <strong>$60/day on Azure SignalR</strong>, if I understood their pricing model correctly.</p>\n<p>Next, I run the chat room test, but this time with connections reduced to 500 since there will be a lot more messages being sent out among the clients. I set the number of rooms to 10, and again with a new client coming every 100 ms and the test duration of 5 minutes. The results:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// dotnetify-proxy1.herokuapp.com</span>\nClients<span class=\"token operator\">=</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> Min latency<span class=\"token operator\">=</span><span class=\"token number\">618.12</span><span class=\"token punctuation\">,</span> Max latency<span class=\"token operator\">=</span><span class=\"token number\">3819.86</span><span class=\"token punctuation\">,</span> Avg Latency<span class=\"token operator\">=</span><span class=\"token number\">1154.09</span><span class=\"token punctuation\">,</span> Received<span class=\"token operator\">=</span><span class=\"token number\">213462</span><span class=\"token punctuation\">,</span> Missed<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token operator\">%</span>\n\n<span class=\"token comment\">// dotnetify-proxy2.herokuapp.com</span>\nClients<span class=\"token operator\">=</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> Min latency<span class=\"token operator\">=</span><span class=\"token number\">631.95</span><span class=\"token punctuation\">,</span> Max latency<span class=\"token operator\">=</span><span class=\"token number\">3315.52</span><span class=\"token punctuation\">,</span> Avg Latency<span class=\"token operator\">=</span><span class=\"token number\">1152.81</span><span class=\"token punctuation\">,</span> Received<span class=\"token operator\">=</span><span class=\"token number\">212945</span><span class=\"token punctuation\">,</span> Missed<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token operator\">%</span></code></pre></div>\n<p>With almost 500K messages sent across 1000 chat users in only 5 to 6 minutes, I can see now how Azure SignalR is making its profit!</p>\n<p>Note that I didn’t always get perfect results on Heroku with the high connection count. Sometimes clients couldn’t connect and threw socket exceptions, or some clients didn’t get a few messages at random times. I think I could attribute it to the fluctuating level of the shared resources on the server nodes. Things were more consistent when the connections were limited to a few hundreds or having lower throughput.</p>\n<p>Building and running these tests were extremely time consuming but they provided me with valuable insights which allow me to improve the reliability and robustness of dotNetify’s codebase. I have since released this as a core feature in dotNetify version 5 (<a href=\"https://github.com/dsuryd/dotNetify/releases/tag/v5.0\">release notes</a>), along with support for Vue version 3.</p>\n<h2>Tools for Sponsors</h2>\n<p>DotNetify will always be FOSS, but it needs an active community and sponsors to grow beyond a side project. If your company is already using dotNetify in production, consider supporting its development and get access to these exclusive new tools I made just for sponsors:</p>\n<h4>DotNetify-Load-Tester:</h4>\n<p>This is the tool I’ve been using to write and run the above tests. If you really want to understand how your dotNetify app will behave under different load scenarios, this is the tool to have.</p>\n<h4>DotNetify-Observer:</h4>\n<p>A web dashboard that can show you in real-time all the active connections with your app, including details like IP addresses, user agents, payload strings, and throughput metrics. The hosted version will give you intel on the CPU and memory usage of the proxy servers (works on either Windows or Linux).</p>","frontmatter":{"title":"Adding \"Azure SignalR\"-like Scale-Out Option","date":"Invalid date","description":"Horizontal scaling using proxy servers"}},"previous":null,"next":null},"pageContext":{"id":"8fa63cce-55f8-5eac-982c-a0a3305e79c3","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}