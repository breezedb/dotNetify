<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[dotNetify]]></title><description><![CDATA[dotNetify]]></description><link>https://dsuryd.github.io/dotNetify</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 02 Aug 2021 06:42:23 GMT</lastBuildDate><item><title><![CDATA[How To Do Real-time Web Updates From Your PostgreSQL Database]]></title><description><![CDATA[I was reading up on PostgreSQL for my day job when I noticed this nifty feature called logical replication. Logical replication, as the…]]></description><link>https://dsuryd.github.io/dotNetify/realtime-postgres/</link><guid isPermaLink="false">https://dsuryd.github.io/dotNetify/realtime-postgres/</guid><pubDate>Wed, 31 Mar 2021 05:58:56 GMT</pubDate><content:encoded>&lt;p&gt;I was reading up on PostgreSQL for my day job when I noticed this nifty feature called logical replication. Logical replication, as the PostgreSQL documentation states, is “a method of replicating data objects and their changes, based upon their replication identity (usually a primary key)“. In other words, it’s a way of ensuring copies of the database are always in sync by having the database publish logical data changes in real-time to subscriber nodes. Typically the subscribers would be other PostgreSQL databases that are serving as copies of the master, but they could actually be anything, including, say, a .NET service that can push those changes to web apps in real-time.&lt;/p&gt;
&lt;p&gt;PostgreSQL has another feature called NOTIFY to generate notifications but we typically need to set it up with database triggers that we have to write for each table we’re interested in, and the string payload size has a limit of 8000 bytes. Logical replication has no such limit and can listen to all tables with a single database connection, making it pretty scalable.&lt;/p&gt;
&lt;p&gt;So, combining it with the real-time web framework &lt;em&gt;dotNetify&lt;/em&gt;, I wrote a small library that you can use to develop a web application with ASP.NET 5 that can react to all the inserts, updates and deletes that any user of the app commits to your PostgreSQL database. With this, your app won’t involve expensive polling, a complicated pub/sub pipeline, or even take much code at all. The rest of the blog will talk about how you can build such app.&lt;/p&gt;
&lt;h2&gt;PostgreSQL Setup&lt;/h2&gt;
&lt;p&gt;To enable logical replication in your PostgreSQL database, find the &lt;em&gt;postgresql.conf&lt;/em&gt; configuration file, change a parameter called &lt;em&gt;wal&lt;/em&gt;level_ to &lt;em&gt;logical&lt;/em&gt;, and both &lt;em&gt;max&lt;/em&gt;wal&lt;em&gt;senders&lt;/em&gt; and _ &lt;em&gt;max&lt;/em&gt;replication&lt;em&gt;slots&lt;/em&gt; to at least 1. They will take effect after the service is restarted. You can also change them through SQL:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;ALTER&lt;/span&gt; SYSTEM &lt;span class=&quot;token keyword&quot;&gt;SET&lt;/span&gt; wal_level&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;logical&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;ALTER&lt;/span&gt; SYSTEM &lt;span class=&quot;token keyword&quot;&gt;SET&lt;/span&gt; max_wal_senders&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;10&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;ALTER&lt;/span&gt; SYSTEM &lt;span class=&quot;token keyword&quot;&gt;SET&lt;/span&gt; max_replication_slots&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;10&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next step is to create a publication:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;CREATE&lt;/span&gt; PUBLICATION my_pub &lt;span class=&quot;token keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TABLES&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We set it to publish data changes for all tables, but you can restrict it to just a specific table.&lt;/p&gt;
&lt;p&gt;When the PostgreSQL is publishing replication records (also known as write-ahead logs or WAL), it uses something called replication slots to ensure that the records do not get deleted until they’re received by the subscribers. This is a great feature, as it affords a subscriber to go temporarily offline, and to simply pick up where it left off when it reconnects. But there’s a caveat: the WAL records can pile up in a prolonged disconnection event, to the point that it can run out of space and crash the database, and therefore, the slots will need to be monitored.&lt;/p&gt;
&lt;p&gt;The followins statemnt will create a replication slot:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; pg_create_logical_replication_slot&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;my_slot&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;pgoutput&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;em&gt;pgoutput&lt;/em&gt; is PostgreSQL’s standard logical decoding plugin for transforming the changes from WAL to the logical replication protocol. If in the future you want to remove the slot, simply run this command: &lt;code class=&quot;language-text&quot;&gt;SELECT * FROM pg_drop_replication_slot(&amp;#39;my_slot&amp;#39;);&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For our demo, let’s create a simple table, followed by a user for the ASP.NET service that will be connecting to the database:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;EXISTS&lt;/span&gt; businesses &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	business_id &lt;span class=&quot;token keyword&quot;&gt;serial&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	business_name &lt;span class=&quot;token keyword&quot;&gt;VARCHAR&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	rating &lt;span class=&quot;token keyword&quot;&gt;integer&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;USER&lt;/span&gt; my_user &lt;span class=&quot;token keyword&quot;&gt;WITH&lt;/span&gt; PASSWORD &lt;span class=&quot;token string&quot;&gt;&apos;my_pwd&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;ALTER&lt;/span&gt; ROLE my_user &lt;span class=&quot;token keyword&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;REPLICATION&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;PRIVILEGES&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TABLES&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;SCHEMA&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TO&lt;/span&gt; my_user&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;USAGE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;ALL&lt;/span&gt; SEQUENCES &lt;span class=&quot;token operator&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;SCHEMA&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TO&lt;/span&gt; my_user&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that we give the REPLICATION role to the user. Having this role is required for subscribing to replication slots.&lt;/p&gt;
&lt;h2&gt;DotNetify Web Service&lt;/h2&gt;
&lt;p&gt;Now that we’ve configured the Postgres, the next step is to introduce an ASP.NET web service to subscribe to the replication slot we just created and push the changes to its web page using the &lt;em&gt;DotNetify.Postgres&lt;/em&gt; library. You can download the source code from &lt;a href=&quot;https://github.com/dsuryd/dotNetify/tree/master/Demo/React/RealtimeDb.Postgres&quot;&gt;this github repo&lt;/a&gt;. This simple demo project uses React/Typescript front-end with Webpack. After installing the npm packages, you can run the project from either Visual Studio or dotnet CLI.&lt;/p&gt;
&lt;p&gt;In the code, the PostgreSQL table we’ve created is mapped to a C# type:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace RealtimeDb.ViewModels
{
  [Table(&amp;quot;businesses&amp;quot;)]
  public class Business
  {
    [Column(&amp;quot;business_id&amp;quot;)]
    [Key]
    public long Id { get; set; }

    [Column(&amp;quot;business_name&amp;quot;)]
    public string Name { get; set; }

    [Column(&amp;quot;rating&amp;quot;)]
    public int Rating { get; set; }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;em&gt;DotNetify.Postgres&lt;/em&gt; library provides a ReactiveX interface to listen to PostgreSQL data change events. The interface is injected into a &lt;em&gt;dotNetify&lt;/em&gt; view model so it can subscribe to the events when the associated React webpage is active and push any updates in real-time:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;using System;
using System.Collections.Generic;
using System.Reactive.Linq;
using DotNetify;
using DotNetify.Postgres;

namespace RealtimeDb.ViewModels
{
   public class ListenOnlyVM : BaseVM
   {
      private IDisposable _subs;

      // Real-time list; documentation: https://dotnetify.net/core/api/crud.
      [ItemKey(nameof(Business.Id))]
      public List&amp;lt;Business&amp;gt; Businesses { get; set; }

      public ListenOnlyVM(IDbChangeObserver dbChangeObserver)
      {
         Businesses = new List&amp;lt;Business&amp;gt;();

         _subs = dbChangeObserver.Observe&amp;lt;Business&amp;gt;().Subscribe(e =&amp;gt;
         {
            if (e is DbInsertEvent&amp;lt;Business&amp;gt;)
            {
               this.AddList(nameof(Businesses), (e as DbInsertEvent&amp;lt;Business&amp;gt;).Row);
            }
            else if (e is DbUpdateEvent&amp;lt;Business&amp;gt;)
            {
               this.UpdateList(nameof(Businesses), (e as DbUpdateEvent&amp;lt;Business&amp;gt;).NewRow);
            }
            else if (e is DbDeleteEvent&amp;lt;Business&amp;gt;)
            {
               var key = (e as DbDeleteEvent&amp;lt;Business&amp;gt;).Row.Id;
               this.RemoveList(nameof(Businesses), key);
            }

            PushUpdates();
         });
      }

      public override void Dispose() =&amp;gt; _subs.Dispose();
   }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The connection string to our PostgreSQL database along with the publication and replication slot names are configured in the service startup class:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;public class Startup
{
  public IConfiguration Configuration { get; }

  public Startup(IConfiguration configuration)
  {
      Configuration = configuration;
  }

  public void ConfigureServices(IServiceCollection services)
  {
      services.AddSignalR();
      services.AddDotNetify();
      services.AddDotNetifyPostgres(new PostgresConfiguration
      {
        ConnectionString = Configuration.GetConnectionString(&amp;quot;Postgres&amp;quot;),
        PublicationName = &amp;quot;my_pub&amp;quot;,
        ReplicationSlotName = &amp;quot;my_slot&amp;quot;
      });
  }
  ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s all there is to it for the server-side code! Here’s what the demo app looks like as it reacted to data changes that were made from pgAdmin.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/dotNetify/493674e3d078e6e7145815c83e4414b1/listen-only.gif&quot; alt=&quot;Listener Demo&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Integrating EF Core&lt;/h2&gt;
&lt;p&gt;So far we have a web page that’s only reacting to data changes on the database. Let’s take it a step further and make it capable of supporting CRUD operations as well. For this, we’re going to use the &lt;a href=&quot;https://www.npgsql.org/&quot;&gt;Npgsql&lt;/a&gt; library to access PostgreSQL, and can be used with the Entity Framework Core.&lt;/p&gt;
&lt;p&gt;Add a DBContext for our demo table:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;using Microsoft.EntityFrameworkCore;

namespace RealtimeDb
{
   public class BusinessDbContext : DbContext
   {
      public DbSet&amp;lt;Business&amp;gt; Businesses { get; set; }

      public BusinessDbContext(DbContextOptions&amp;lt;BusinessDbContext&amp;gt; options) : base(options)
      {
      }
   }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Configure the EF Core in the startup class:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;public class Startup
{
  public void ConfigureServices(IServiceCollection services)
  {
    ...
    services.AddDbContextFactory&amp;lt;BusinessDbContext&amp;gt;(options =&amp;gt;
      options.UseNpgsql(Configuration.GetConnectionString(&amp;quot;Postgres&amp;quot;)));
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lastly, write the view model with the CRUD methods:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c#&quot;&gt;&lt;pre class=&quot;language-c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;public class BusinessesVM : BaseVM
{
  private readonly IDbContextFactory&amp;lt;BusinessDbContext&amp;gt; _dbContextFactory;

  [ItemKey(nameof(Business.Id))]
  public List&amp;lt;Business&amp;gt; Businesses { get; set; }

  public BusinessesVM(IDbContextFactory&amp;lt;BusinessDbContext&amp;gt; dbContextFactory, IDbChangeObserver dbChangeObserver)
  {
      _dbContextFactory = dbContextFactory;

      using var dbContext = _dbContextFactory.CreateDbContext();
      Businesses = dbContext.Businesses.OrderBy(x =&amp;gt; x.Id).ToList();

      this.ObserveList&amp;lt;Business&amp;gt;(nameof(Businesses), dbChangeObserver);
  }

  public void Add(Business businessInfo)
  {
      using var dbContext = _dbContextFactory.CreateDbContext();
      dbContext.Businesses.Add(businessInfo);
      dbContext.SaveChanges();
  }

  public void Update(Business businessInfo)
  {
      using var dbContext = _dbContextFactory.CreateDbContext();
      var business = dbContext.Businesses.Find(businessInfo.Id);
      if (business != null)
      {
        business.Name = businessInfo.Name;
        business.Rating = businessInfo.Rating;
        dbContext.SaveChanges();
      }
  }

  public void Remove(Business businessInfo)
  {
      using var dbContext = _dbContextFactory.CreateDbContext();
      var business = dbContext.Businesses.Find(businessInfo.Id);
      if (business != null)
      {
        dbContext.Businesses.Remove(business);
        dbContext.SaveChanges();
      }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that the code that does the subscription and data change event handling are gone. In its place is now a call to &lt;em&gt;ObserveList&lt;/em&gt; extension method, which serves as a shorthand.&lt;/p&gt;
&lt;p&gt;And here’s the demo of two instances of the app keeping in sync with each other while we apply some CRUD operations:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/dotNetify/76b2b86d54ccd8e7f202a8cea66e5236/businesses-crud.gif&quot; alt=&quot;CRUD Demo&quot;&gt;&lt;/p&gt;
&lt;p&gt;I hope this is useful to you! I’d be interested to hear what you think. Reply to the tweet below and let me know. And feel free to retweet!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Recreating "Azure SignalR" Scale-Out]]></title><description><![CDATA[Just a few weeks ago dotNetify passed the 100k NuGet downloads. I’m thrilled that so many people have found this project compelling enough…]]></description><link>https://dsuryd.github.io/dotNetify/scale-out/</link><guid isPermaLink="false">https://dsuryd.github.io/dotNetify/scale-out/</guid><pubDate>Wed, 31 Mar 2021 05:58:56 GMT</pubDate><content:encoded>&lt;p&gt;Just a few weeks ago &lt;a href=&quot;https://dotnetify.net&quot;&gt;dotNetify&lt;/a&gt; passed the 100k NuGet downloads. I’m thrilled that so many people have found this project compelling enough to try out, and based on the feedback I’ve been getting, it’s being used in production as well!&lt;/p&gt;
&lt;p&gt;For those who are unfamiliar with dotNetify, it’s an Apache2-licensed FOSS that does the following in a nutshell:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dotNetify provides a layer of MVVM-styled abstraction over SignalR to facilitate real-time communication between the web front-end of your application and its ASP.NET Core back-end.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It offers built-in integration with some client-side frameworks, such as &lt;strong&gt;React&lt;/strong&gt;, &lt;strong&gt;Vue&lt;/strong&gt;, and &lt;strong&gt;Blazor&lt;/strong&gt;, resulting in code that’s declarative, concise, and easy to read. For example, here’s what it would look like to implement a rudimentary stock ticker UI using Vue:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/cd536/stock-ticker-code.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB2ElEQVQoz22Ry27TQBSG8wqQRKSosefmGTu+pUkR4gWoRJKC4E27aFkECbFAwKLtoouuEKCuGuXmOPbM2B5zLBUhJI6O/tX85/vPmZYfekejsYDiHARjjGxECen1eicnL2+vv95efZ5/vDx7/+3s4svFh6v5p5vz+fX5/BK6ZVt94sWD0Ys48MPx8/DoOIpib/jsENPXb99lZf3rLkuSVf2/aiFkUe578bEXxm44dIMh9wIm3INDa3b6ZqOSzVqmqSwq03RZVZVp2jTawgg7IkDMtW1EbIsgy+r3bctqP370ajIzdZ3uytXabHfFNtcwJM/zoigfyASTOByP4rHHBcOYYYRgDEKdTnsymcGLfVpudmqviyStklTvdkmaKq2rugYywWLgR1HoDnzKXYdTwYjrsCcHT6fTUzDnmVqutpvtNlMKHLooof6QCRGuCKLI8wRqqBDZeiBPm9hAWK+XP77/XNyv8zwzxvw9GKHUBx8XiDqYMMIFjIMZ7XZjbqzGyDxbLJZpmmmt/jHDxwo/8KIhdwhzHMJdTB3uDrrdLuxcNbH1fl8o3ezZiNZSymyfweValDFKKMKQAAMTU2YjEKfb7QC5NLlSpVJGSiVlKaXWRaGUznMJ+hs9v0ztfT1RaAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Stock Ticker - Vue&quot;
        title=&quot;Stock Ticker - Vue&quot;
        src=&quot;/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/f058b/stock-ticker-code.png&quot;
        srcset=&quot;/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/c26ae/stock-ticker-code.png 158w,
/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/6bdcf/stock-ticker-code.png 315w,
/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/f058b/stock-ticker-code.png 630w,
/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/40601/stock-ticker-code.png 945w,
/dotNetify/static/203bd6a152cdff20e9e56290fa94a3e0/cd536/stock-ticker-code.png 1114w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Doesn’t it look clean? You only write views and its view models, and automatically get access to the bidirectional, real-time functionality provided by SignalR without having to write the low-level code yourself.&lt;/p&gt;
&lt;h2&gt;SignalR Scale-Out Options&lt;/h2&gt;
&lt;p&gt;Running a dotNetify app on a single server is pretty straightforward, but on a few occasions, questions were asked about its scalability in a multi-server architecture. Scaling SignalR-based apps horizontally is tricky compared to REST APIs. There are at least two main issues to contend with:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Since SignalR connection is stateful, when a client sends a request to a server, subsequent requests must go to the same server.&lt;/li&gt;
&lt;li&gt;Every server is only aware of its own client connections. If the app needs to broadcast to all clients, the payload must first be delivered to all servers so they can broadcast it to their respective clients.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first issue can be solved by either configuring the load balancer so it always redirect the requests from a particular client to the same server (so-called “sticky sessions”), or making SignalR skips its transport negotiation and go straight to the persistent WebSocket connection. Still, either way gives rise to a harder problem: sticky connections stick to one server, and if that server is at capacity, how can we redistribute the load to a new server? But this is a discussion for another day.&lt;/p&gt;
&lt;p&gt;The second issue is commonly addressed by having an intermediary server with a pub/sub channel to which every app server subscribes. Incoming client messages to one server are published to the channel so the other servers may get them too. The SignalR documentation refers to this as a “backplane” and recommends using Redis due to its fast in-memory store.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 614px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.59493670886076%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACKklEQVQoz2VTTW8SQRjeH+RNDx5MvHoxeDImJh6IcquJmnrQg02L/gDOcPFmTcpJCAfjAZpiJBUL1dBSWpbvsmzZL2BmZ/ZxZteFpT7JZD7yzjPP+7zvKNVqFYVCAeVyGRKe560NhLOAadk4b3dACEEIz6Xgi5k/5FrJ5/NIJBKIxWJrhMu1mBnj/v5b8QCPn75A60L194RSsLkgogRcDkGqZLNZlEol5HI56JYLzldkqwc4CAM+7eVw4/Y9/Kr9BhNqpoYBOnMAzuAxBk7mUBCBNaPQDLIkCskNx8Wk10Vx/wAv37zHhdpd3pEkQR7BWlFVFf1+H7p+5R/qJvUJQjAR22t3QU0NV1MDlmn6HoZ2cLKAZ1uglyORsiCsVCp4vrGBzc3XwGwKd9JDRxhfq9VRPz7G6UkD9qWK6wgt4S7B0ZOHKN+5iYWuQUmn00ilUtjaehcY7S4w1vs4a56h0WgI5RPo9hhUXJSSQnUIE/UYWvkvONn7DIjCKMPhEFRUK8R4OoDL3DU1RASa8wn2v//Aq7cf0OkNAnUybZFyezDAubDNT3k0GsEQ1SKEiiqPYc+tf8E80o8B8cfdXdy6+wBH9T9wxSPSUzqzfbUyyCc8/HmI7e1tJJM7mFPnv5bxCyNaQqLwtYj7j56hcdoKzjkPmjrah5lMRpAlEY/HA2U8ogyrJpfnshtUtQPHcVbFEfYsf4pYK81mE5qmrRNd+y2rvmTLrxiNieIvSo99waJyhU8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Redis Backplane&quot;
        title=&quot;Redis Backplane&quot;
        src=&quot;/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png&quot;
        srcset=&quot;/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/c26ae/backplane.png 158w,
/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/6bdcf/backplane.png 315w,
/dotNetify/static/bf9bfca531f728f2b4d568c22eeb2300/e9131/backplane.png 614w&quot;
        sizes=&quot;(max-width: 614px) 100vw, 614px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In 2018, Microsoft started to offer its cloud solution in place of Redis — the Azure SignalR Service. What’s interesting is that it doesn’t use a pub/sub broker, but what looks to be a cluster of reverse proxies. Instead of duplicating the app servers, it puts this cluster of proxy servers in front of the app server and maintains a fixed number of persistent connections between them. Any client that attempts to establish a connection to the app server will be redirected to connect with a proxy. And for the duration of the connection, the proxy will forward the messages between the client and the app server.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 484px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.31645569620254%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGklEQVQ4y5VUO48SURSe/0OrFnRIbWFNLaEyWSu0tuIHuKEihFCQQNzCwgJJpAAKYHV5uLjGjbLjME/GOzzmyee9l2VgF9aEk5zcO/ee+eac831nBEIIWq0Wms0mer0eRFGE7/tgtlqtuB9jQrvdRqPRgGEYSCQSSKVSCIIt4O56yDYf3bigaRqy2SxyuRySySSi0Shsd7UHuOv371hFzDkgO5RlGZ1OB6ZpQtc1yIYN03L3wO634VDmwubQdV14nhde3KgLOK5/JzgIgu3+9j2W2afPDXz4WMNiuYTAgljZzB3HCUF9Gn+j2fD8ABONQNLmEBWCsTSlwNvMXBqffPkGzxMpqJoOodvtolarYTgcIp1O493pKZwZwWoxBaFEXV5r0E0L518uOHHW3MXP3woIMW9bRMl8cYKnzxKQFQ0Ck0qpVOJMx2IxPHr8BPCWsHUJvqXg6tcEE9XExddzSJKEH2MDMs3Y91zeptl8jpPXbynoK5qhsSalWq2iXC5zPZ6dvQ/LkaYiphYtc/IXynRBVwLVmN3pq2VZGH67xOj7FWzbXgMyYwLfNYOolGk9fHZcLyRll2nW83XvXX7PWVYUhfuSsuR5Phb2jEpHPDgtD+1D2YxGI05Kv99HJpNBsVjEH3UMP/D+K+qHRC8MBgNUKhUu7Hg8jkgkspfBMfMcklIoFFCv15HP5/fm9Kifw2ajqurBph8L+A+Xa2SJzQ6IvgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Azure SignalR&quot;
        title=&quot;Azure SignalR&quot;
        src=&quot;/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png&quot;
        srcset=&quot;/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/c26ae/azure-signalr.png 158w,
/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/6bdcf/azure-signalr.png 315w,
/dotNetify/static/19ad0f9c58609cbf8886ec29dbcaac28/ff42b/azure-signalr.png 484w&quot;
        sizes=&quot;(max-width: 484px) 100vw, 484px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The messages are multiplexed through that constant number of connections, which means that the app server won’t be sensitive to how many active client connections there are, only the message throughput.&lt;/p&gt;
&lt;p&gt;Between the two scale-out options, the proxy method seems to be the better option because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The app server won’t need to scale just to handle a large number of concurrent connections, especially when they’re mostly idle.&lt;/li&gt;
&lt;li&gt;The app server won’t waste its resources maintaining connections.&lt;/li&gt;
&lt;li&gt;The app server can be made aware of all the connections and can use connection ids to keep track of clients.&lt;/li&gt;
&lt;li&gt;You won’t have to deal with the hassle of managing (or paying for) Redis.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The obvious downside is that if you can’t/won’t run on Azure, then you don’t get that option! Even without the cost consideration, many still face restrictions on which cloud provider they can use, if at all.
In the following section, I describe my effort to make it so that dotNetify apps can use the proxy scale-out option either on-prem or on non-Azure cloud providers.&lt;/p&gt;
&lt;h2&gt;Forwarding Middleware&lt;/h2&gt;
&lt;p&gt;The Azure SignalR Service is not open source, so I could only guess how the proxying is actually done, but it can be surmised that the ability to forward messages from one SignalR hub server to another is the key piece. The thought of using the dotNetify middleware mechanism immediately jumped out to me.&lt;/p&gt;
&lt;p&gt;DotNetify middlewares are similar to ASP.NET middlewares in concept, but instead of HTTP requests, they intercept SignalR messages. They are intended to process payload metadata, such as JWT access tokens and custom initialization arguments, and can be chained to form a pipeline.&lt;/p&gt;
&lt;p&gt;The idea I ran with was to introduce a middleware that makes a fixed number of SignalR connections to an app server and passes all client messages through these connections. They’re also bi-directional — passing messages from the app server to the intended clients. In essence, its purpose is to facilitate logical connections between the app server and the clients.&lt;/p&gt;
&lt;p&gt;Implementing scale-out then becomes a matter of enabling this middleware on some plain, inexpensive proxy servers:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 599px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 61.39240506329114%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5UlEQVQoz31Tu47TQBT1T/EB/EF6pKWiWSqkFKRDSofSAEsVEokS0VCRIg9twaJEKGSTFImMnDjRxgTj9yP2esY+eMYkIcPCkcZ3Hude33vmjjSdTjEajdDpdKAoChiyLDvYu+Z7iOcMUrvd5gFLpRLK5TLfJIScOBfzYh3HMcIw5FYMzIa0WCzQaDTQan1Et3cJn/OyExJb0zSD7RN8vvqE4XCI2WyG3W73V9YSBFhuDDdIxG38NH3Y2hqmZWG1WkHXdR7QcRykaXoMyA4nkwkneb5fOLsEYUyRMWKWwg0JtuoSoDEvnEmyD8LmG22Lp8+eo3N5Banb7UKWZZydPcTri4ucEeDW1iF/UzAeX2N0PcZakUFD+7dex2wopdze5AHv3S/hzdt3kAaDAer1OqrVKrcMnqvnJW6xudlA077DD5w86y3uAqUES3WNB4+e4P2HVqEh02EPklIYno5McIxuQxjuD0RRhCAI+C0zDT3Pg+u6WC5VWJYNyTAMsJs2TRMJSaA7GghNhHYoyoySEMOvX9Dv9zGfz/PstQOPacp4Uq/X4xqenz/Gy1cvCkIqts2xcVlG7AGoqnrQ8M/W4Ro2m01UKhXUarWi7FwXsWFFx9OmP3Il9mEZsu4Xg/zvCf7rR78ALBWFjFlNb84AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Forwarding Proxy&quot;
        title=&quot;Forwarding Proxy&quot;
        src=&quot;/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png&quot;
        srcset=&quot;/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/c26ae/forwarding-proxy.png 158w,
/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/6bdcf/forwarding-proxy.png 315w,
/dotNetify/static/6a916f1e3d5c39fb9db7498e9bdc5c77/43142/forwarding-proxy.png 599w&quot;
        sizes=&quot;(max-width: 599px) 100vw, 599px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;A proxy server is simply a bare-bone ASP.NET Core web app with the following code in &lt;code class=&quot;language-text&quot;&gt;Startup.cs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;csharp&quot;&gt;&lt;pre class=&quot;language-csharp&quot;&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;DotNetify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;DotNetify&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Forwarding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token range operator&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;ProxyServer&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Startup&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;IServiceCollection&lt;/span&gt; services&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         services&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;AddSignalR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         services&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;AddDotNetify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;IApplicationBuilder&lt;/span&gt; app&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;UseWebSockets&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;UseDotNetify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;config &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            config&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;UseForwarding&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;app_server_url&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;UseRouting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;UseEndpoints&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ep &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; ep&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token generic-method&quot;&gt;&lt;span class=&quot;token function&quot;&gt;MapHub&lt;/span&gt;&lt;span class=&quot;token generic class-name&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;DotNetifyHub&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/dotnetify&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An important consideration was to make sure that the view models or other middlewares won’t be aware of the proxies. A multicast view model that uses connection ids to track clients should not be implemented any different when it’s operating behind proxies than when it’s not. This was solved by having the receiver end on the app server create a logical connection context that exposes the original connection id.&lt;/p&gt;
&lt;h2&gt;Forwarding Options&lt;/h2&gt;
&lt;p&gt;The forwarding middleware provides the following options:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;csharp&quot;&gt;&lt;pre class=&quot;language-csharp&quot;&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ForwardingOptions&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt; ConnectionPoolSize &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;Func&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;DotNetifyHubContext&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; Filter &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; UseMessagePack &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; HaltPipeline &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ConnectionPoolSize:&lt;/strong&gt; the number of SignalR connections the proxy server will establish with the app server. Messages to be delivered will take turns using a connection from the pool in a round-robin fashion. Naturally, the pool size should be increased if the anticipated throughput is high.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Filter:&lt;/strong&gt; optional predicate for whether or not to forward a message. Chaining multiple forwarding middlewares with filters allow for all kinds of interesting configuration, such as having specialized app servers handling different user groups or certain types of view models.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UseMessagePack:&lt;/strong&gt; use MessagePack serialization format to keep the payload small.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HaltPipeline:&lt;/strong&gt; stop processing beyond the middleware. This flag allows the middleware to be used not just for scale-out, but for observability, i.e. sending messages to a real-time monitoring server.&lt;/p&gt;
&lt;h2&gt;Devising Load Tests&lt;/h2&gt;
&lt;p&gt;Needless to say, substantial code refactoring had to be done to dotNetify for this, and I needed to build confidence that the whole thing would actually work! First, I would need a load testing tool to emulate a high number of concurrent client connections. There’s a Microsoft benchmark tool called &lt;a href=&quot;https://github.com/dotnet/aspnetcore/tree/main/src/SignalR/perf/benchmarkapps/Crankier&quot;&gt;Crankier&lt;/a&gt;, but it only tries to hold open connections and not measuring anything related to the message payload.&lt;/p&gt;
&lt;p&gt;In the end, I built my own tool that can be customized for any kind of workload, and wrote some test profiles according to what I thought were the most common ones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Broadcast:&lt;/strong&gt; The server pushes updates to all clients at regular intervals. A single multicast view model instance is used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Echo:&lt;/strong&gt; Continuous back and forth communication between the client and the server. The server sends a message to the client and waits for the response before sending the next one.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Chat Room:&lt;/strong&gt; This profile models chat rooms where clients are sending and receiving messages with each other and within groups. The clients within a group are configured into 3 types:&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;margin-left: 30px&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Chatty posters (10%): send a message every 11 seconds.&lt;/li&gt;
&lt;li&gt;Casual posters (20%): send a message every 59 seconds.&lt;/li&gt;
&lt;li&gt;Lurkers (70%): only receive messages.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;The message payload contains a sequence number and a timestamp to allow the test to detect undelivered messages and measure the average round-trip latency. &lt;a href=&quot;https://github.com/dsuryd/dotNetify-LoadTester.Profiles&quot;&gt;The source code is available here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next, I created an app server with the test view models and deployed it along with 2 proxy servers to a free-tier Heroku container environment. According to the specs, each server node only has 500MB memory and 1x CPU share, so I would have to balance the number of connections with the throughput so as not to overwhelm the resources.&lt;/p&gt;
&lt;p&gt;I ran my tool from my own machine to emulate client connections. I set the connections to 1000 (following the limit on an Azure SignalR standard unit) with a new connection every 100 ms, running a broadcast test with 3 seconds interval for 5 minutes. The results:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// dotnetify-proxy1.herokuapp.com&lt;/span&gt;
Clients&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Received&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;134262&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Missed&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Min interval&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3003.35&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Max interval&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3088.73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Avg interval&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3034.29&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// dotnetify-proxy2.herokuapp.com&lt;/span&gt;
Clients&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Received&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;134263&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Missed&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Min interval&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3004.32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Max interval&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3122.66&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Avg interval&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3034.98&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With each connection passing 20 messages/minute, 2000 concurrent connections running for just 1 day would generate close to 58 million messages and would’ve cost me about &lt;strong&gt;$60/day on Azure SignalR&lt;/strong&gt;, if I understood their &lt;a href=&quot;https://azure.microsoft.com/en-us/pricing/details/signalr-service/&quot;&gt;pricing model&lt;/a&gt; correctly.&lt;/p&gt;
&lt;p&gt;Next, I run the chat room test, but this time with connections reduced to 500 since there will be a lot more messages being sent out among the clients. I set the number of rooms to 10, and again with a new client coming every 100 ms and the test duration of 5 minutes. The results:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// dotnetify-proxy1.herokuapp.com&lt;/span&gt;
Clients&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Min latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;618.12&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Max latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3819.86&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Avg Latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1154.09&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Received&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;213462&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Missed&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// dotnetify-proxy2.herokuapp.com&lt;/span&gt;
Clients&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Min latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;631.95&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Max latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3315.52&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Avg Latency&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1152.81&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Received&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;212945&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Missed&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With almost 500K messages sent across 1000 chat users in only 5 to 6 minutes, I can see now how Azure SignalR is making profit!&lt;/p&gt;
&lt;p&gt;It must be noted that I didn’t always get perfect results on Heroku with the high connection count. Sometimes clients couldn’t connect and threw socket exceptions, or there were missed messages at random times. I would attribute this to the fluctuating level of the shared resources on the server nodes. Things were more consistent when the connections were limited to a few hundred or having lower throughput.&lt;/p&gt;
&lt;p&gt;Building and running these tests were extremely time-consuming but they provided me with valuable insights which allow me to improve the reliability and robustness of dotNetify’s codebase. I have since released this as a core feature in dotNetify version 5 (&lt;a href=&quot;https://github.com/dsuryd/dotNetify/releases/tag/v5.0&quot;&gt;release notes&lt;/a&gt;).&lt;/p&gt;
&lt;h2&gt;Tools for Sponsors&lt;/h2&gt;
&lt;p&gt;DotNetify will always be FOSS, but it needs an active community and sponsors to grow its capability to serve more demanding production needs. If your company is already using dotNetify in production, consider supporting its development and get access to these exclusive new tools made just for &lt;a href=&quot;https://github.com/sponsors/dsuryd&quot;&gt;sponsors&lt;/a&gt;:&lt;/p&gt;
&lt;h4&gt;DotNetify-Load-Tester:&lt;/h4&gt;
&lt;p&gt;This is the tool I’ve been using to write and run the above tests. If you really want to understand how your dotNetify app will behave under different load scenarios, this is the tool to have.&lt;/p&gt;
&lt;h4&gt;DotNetify-Observer:&lt;/h4&gt;
&lt;p&gt;A web dashboard that can show you in real-time all the active connections with your app, including details like IP addresses, user agents, payload strings, and throughput metrics. The hosted version will give you intel on the CPU and memory usage of the proxy servers (works on either Windows or Linux).&lt;/p&gt;
&lt;p&gt;Here’s a demonstration:&lt;/p&gt;
&lt;video width=&quot;100%&quot; controls=&quot;&quot; style=&quot;border: 1px solid #ccc; margin-bottom: 1.5rem; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)&quot;&gt;
    &lt;source src=&quot;https://dotnetify.net/Content/Videos/scaleout-demo.mp4&quot; type=&quot;video/mp4&quot;&gt;
&lt;/video&gt;
&lt;p&gt;At the moment this tool hasn’t been optimized for large number of connections and/or high throughput and will show serious lags in such cases. But with &lt;a href=&quot;https://github.com/sponsors/dsuryd&quot;&gt;your sponsorship&lt;/a&gt;, this could be improved!&lt;/p&gt;</content:encoded></item></channel></rss>